import networkx as nx
import numpy as np
import numpy.typing as npt

from gspkit import typing
from gspkit import filters
from gspkit import input_checks

def gen_signals(
    graph: nx.Graph,
    n_signals: int,
    fltr: typing.FilterType | str = "gaussian",
    fltr_params: dict = {},
    noise: float = 0.1,
    rng: typing.RNGType = None,
) -> npt.NDArray:
    r"""Generate a set of graph signals from a given graph and filter type.

    Graph signals are generated by filtering a white noise graph signal through
    the input graph. In particular, let $\mathbf{L}$ be the Laplacian of the
    input graph. A graph signal $\mathbf{x}$ is generated by: 
    
    $$ 
    \mathbf{x} = h(\mathbf{L})\mathbf{x}_0 + \mathbf{e}, 
    $$ 
    
    where $h(\cdot)$ is the graph filter, $\mathbf{x}_0$ is the input signal 
    and $\mathbf{e}$ is the additive noise. Both $\mathbf{x}_0$ and $\mathbf{e}$
    are drawn from $\mathcal{N}(\mathbf{0}, \mathbf{I})$.

    Parameters
    ----------
    graph : 
        Input graph.
    n_signals : 
        Number of signals to generate.
    fltr : 
        Graph filter to use to generate data. Available options are listed below
        and their details can be found at
        [FilterType][gspkit.typing.FilterType].

        ??? note "Available Options"
            ```python exec="1" 
            from gspkit import typing 
            for t in typing.FilterType:
                print(f"- `#!python '{t.value}'`")
            ```
    fltr_params : 
        Graph filter parameters. Some of the available filters accept parameters 
        that change their spectrum. These parameters can be provided as a 
        dictionary, which will be passed as arguments to the filter functions.
        See filter details to see parameters accepted by different filters. 
        If empty dictionary, default parameter values set in filter definitions 
        are used.
    noise : 
        Amount of Gaussian noise to add to generated graph signals. Amount of 
        noise is determined in L2-sense, that is 
        $||\mathbf{e}||_2/||h(\mathbf{L})\mathbf{x}_0||_2$ is set to `#!python noise`.
    rng : 
        Random number generator.

    Returns
    -------
    signals : 
        (N, `#!python n_signals`) dimensional matrix whose columns are generated 
        signals, where N is the number of nodes.
    """

    # Check if filter type is valid
    if isinstance(fltr, str):
        try:
            fltr = typing.FilterType(fltr)
        except ValueError:
            raise ValueError("Invalid filter type.")
    fltr = fltr.value

    rng = input_checks.check_rng(rng)
    n_nodes = graph.number_of_nodes()

    fltr_mapping = {
        "gaussian": lambda : filters.gaussian(graph, **fltr_params),
        "heat": lambda : filters.heat(graph, **fltr_params),
        "tikhonov": lambda : filters.tikhonov(graph, **fltr_params), 
    }

    fltr_mat = fltr_mapping[fltr]()

    X0 = rng.multivariate_normal(np.zeros(n_nodes), np.eye(n_nodes), n_signals).T
    X = fltr_mat @ X0

    # Add noise
    X_norm = np.linalg.norm(X)
    E = rng.normal(0, 1, X.shape)
    E_norm = np.linalg.norm(E)
    X += E * (noise * X_norm / E_norm)

    return X
